import sys
input = sys.stdin.readline


## 발상 1
## [서류 순위 & 면접 순위] 담은 리스트를 sort 함
## 리스트에서 왼쪽에 있는 지원자이면 오른쪽에 있는 지원자보다 서류 순위가 높다.
## 따라서 왼쪽 지원자와 오른쪽 지원자를 비교할 때 오른쪽 지원자의 면접 순위가 필수적으로 높아야 한다.
## 가장 왼쪽에 있는 지원자는 이미 서류 순위 1등이기 때문에 결과에 포함하고 이 지원자의 면접 순위를 저장한다.
## 리스트를 순회하면서 오른쪽 지원자의 면접 순위가 포인터(기존 면접 순위)보다 높다면 결과에 추가하고 포인터를 갱신
## 이렇게 끝까지 리스트를 순회한다.

# T = int(input())
# for _ in range(T):
#     n = int(input())
#     lst = [ list(map(int, input().split())) for _ in range(n)]
#     lst.sort()

#     res = 1 
#     pointer = lst[0][1]             # 면접 등수
#     for i in range(n-1):
#         if pointer > lst[i+1][1]:
#             res += 1
#             pointer = lst[i+1][1]

#     print(res)


######################################################################################################
######################################################################################################


## 발상 2
## 원리는 발상 1과 같다.
## 시간과 메모리를 줄이기 위한 방법이다.
## 어차피 같은 등수는 없기 때문에 서류 등수를 리스트의 인덱스로 잡고 값은 면접 등수로 할당한다.
## 2차원 배열을 쓰지 않는 것이다.

T = int(input())
for _ in range(T):
    n = int(input())
    lst = [0] * (n+1)
    for _ in range(n):
        a, b = map(int, input().split())
        lst[a] = b

    pointer = lst[1]
    for i in range(2, n+1):
        if lst[i] < pointer:
            pointer = lst[i]
        else:
            n -= 1
    print(n)