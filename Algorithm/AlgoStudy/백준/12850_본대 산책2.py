# 공부가 정말 많이 되었던 문제
# 1. 인접행렬의 거듭제곱의 의미
# 2. 분할 정복을 활용한 거듭제곱의 효율성


# 1. 인접행렬의 거듭제곱의 의미
# 이 문제는 정점의 중복처리 제한 없이 연결된 모든 정점으로 이동할 수 있음
# 따라서 N번의 단계를 거쳐서 A -> Z 까지 이동할 때의 모든 경우의 수를 구하는 문제

# 인접행렬의 거듭제곱
# 행을 출발점, 열을 도착점이라고 했을 때,
# 행렬 P에 대한
# (P**N)[A][Z]의 값은 A에서 출발하여 N 단계를 거쳐서 Z에 도착하는 모든 경우의 수
# 따라서 이 문제는 인접행렬 P의 P**D[0][0]의 값을 구하는 문제이다(출발점과 도착점이 같음)

# ex) 3*3 행렬을 제곱할 때
# P**2[1][2]
# = P[1][0] * P[0][2] => 1 - 0 - 2 경로의 경우의 수
# + P[1][1] * P[1][2] => 1 - 1 - 2 경로의 경우의 수
# + P[1][2] * P[2][2] => 1 - 2 - 2 경로의 경우의 수


# 2. 분할 정복을 활용한 거듭제곱의 효율성
# 일반적인 거듭제곱은 A**N을 할 때, A를 N번 곱한다 => O(N)
# 만약 N이 과도하게 클 경우에 연산에 문제가 될 수 있다
# 이를 분할 정복을 통해 해결하면 시간복잡도를 O(logN)으로 줄일 수 있다

# 분할 정복을 활용한 거듭제곱
# 1) a ** 100 = (a ** 50) * (a ** 50)
# 2) a ** 50 = (a ** 25) * (a ** 25)
# 3) a ** 25 = (a ** 12) * (a ** 12) * a
# 4) a ** 12 = (a ** 6) * (a ** 6)
# 5) a ** 6 = (a ** 3) * (a ** 3)
# 6) a ** 3 = (a ** 1) * (a ** 1) * a

# 일반적 거듭제곱으로는 100번의 연산이 필요하지만
# 지수가 홀수인 경우에 추가로 a를 한번 더 곱하는 연산을 제외하면
# 이 방법으로는 6(=log100)번의 연산으로 a ** 100을 구할 수 있다

# 이 문제는 D가 10억이기 때문에 일반적 거듭제곱으로는 구할 수 없다
# 따라서 분할 정복을 통한 거듭제곱으로 문제를 해결해야 한다


import sys
input = sys.stdin.readline

SIZE = 8
MOD = 10_0000_0007

adj_mat = [
    [0, 1, 1, 0, 0, 0, 0, 0],
    [1, 0, 1, 1, 0, 0, 0, 0],
    [1, 1, 0, 1, 1, 0, 0, 0],
    [0, 1, 1, 0, 1, 1, 0, 0],
    [0, 0, 1, 1, 0, 1, 1, 0],
    [0, 0, 0, 1, 1, 0, 0, 1],
    [0, 0, 0, 0, 1, 0, 0, 1],
    [0, 0, 0, 0, 0, 1, 1, 0]
]

# 행렬의 곱


def multi(mat1, mat2):
    new_mat = [[0 for _ in range(SIZE)] for _ in range(SIZE)]
    for i in range(SIZE):
        for j in range(SIZE):
            for k in range(SIZE):
                new_mat[i][j] += (mat1[i][k] * mat2[k][j]) % MOD
            new_mat[i][j] %= MOD
    return new_mat


def pow(n):
    # n이 1이면 인접행렬 반환
    if n == 1:
        return adj_mat

    # n을 2로 나눈 몫과 나머지
    share, is_odd = divmod(n, 2)
    # share번 거듭제곱한 행렬을 구함
    divided_mat = pow(share)
    # n번 거듭제곱한 행렬 = share번 거듭제곱한 행렬 ** share번 거듭제곱한 행렬
    powered_mat = multi(divided_mat, divided_mat)
    # 홀수인 경우 인접행렬을 한번 더 곱함
    if is_odd:
        powered_mat = multi(powered_mat, adj_mat)

    # n번 거듭제곱한 행렬 반환
    return powered_mat


n = int(input())
print(pow(n)[0][0])
