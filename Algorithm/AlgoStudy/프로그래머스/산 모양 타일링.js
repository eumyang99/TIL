// 발상
// 왼쪽부터 차례대로 각각의 역삼각형을 기준으로 4 가지 경우로 나눔
// 역삼각형을 사용하지 않음 : 0
// 역삼각형과 위쪽 삼각형을 사용 : 1
// 역삼각형과 왼쪽 삼각형을 사용 : 2
// 역삼각형과 오른쪽 삼각형을 사용 : 3

// CASE [1, 1, 0, 1]
// 차례대로     0,    1,    2,        3     의 경우의 수
// 1 역삼각형 : 1,    1,    1,        1     => 4
// 2 역삼각형 : 4,    4,    (4-1),    4     => 15
// 3 역삼각형 : 15,   X,    (15-4),   15    => 41
// 4 역삼각형 : 41,   41,   (41-15),  41    => 149

// 점화식
// F(n) = {(2 or 3) * F(n-1)} + (F(n-1) - F(n-2))
//      = {(3 or 4) * F(n-1)} - F(n-2)
// 위쪽 삼각형 유무에 따라 각각 3과 4로 정해짐

// 문제
// 마지막에 10007로 나눌 경우 그 과정에 숫자가 너무 커져 오답 처리됨
// 중간에 계속 10007로 나눈 나머지로 숫자 크기를 줄임
// 그러나 F(n)을 나머지로 정의해 갈 경우
// 점화식에서 {(3 or 4) * F(n-1)} 보다 F(n-2)가 큰 경우 F(n)이 음수가 되어 의도대로 점화식이 이어지지 않음
// 이 경우 음수가 된 F(n)에 10007을 다시 더해서 해결

// 10007을 더하는 방법이 직관적으로 떠올라서 해결했지만
// 증명을 한 뒤에도 차후 응용할 수 있을 정도로 직관적 이해는 되지 않는 상황

// 증명
// CASE 1) [3, 3, -100, 3]
// 이 경우 F(n) = (3 * 3) - 100
// 만약 중간에 나머지로 바꾸지 않았다면
// CASE 2) [10010, 10010, -100, 10010] 와 같은 상황
// 우리가 원하는 것은 CASE 1에 결과를 CASE 2의 결과와 같게 하는 것

// A = 10007, B = 3, C = -100, % = 나머지 기호
// [CASE 1] 3*B + C
// [CASE 2] (A+B)*3 + C
//         = 3*A + (3*B + C)
// [CASE 2]의 나머지 값 = {3*A + (3*B + C)} % A
// = (3*A % A) + (3*B + C) % A
// 그러나 3*B + C가 음수이기 때문에 앞의 A를 하나 가져와서
// = (2*A % A) + (3*B + C + A) % A
// (2*A % A) = 0 이기 때문에
// = (3*B + C + A) % A
// (3*B + C + A) % A 에서 (3*B + C)는 음수이기 때문에 (3*B + C) + A < A
// = (3*B + C) + A
// 따라서 [CASE 2]의 나머지 값 = [CASE 1] + A

function solution(n, tops) {
  // 초기화
  let before_sum = 1;
  // 처음 위쪽 삼각형이 있으면 4
  // 없으면 3
  let sum = 3 + tops[0];

  // 이후 삼각형을 순회하며
  for (let i = 1; i < n; i++) {
    // 다음 sum 값을 임시 저장
    let next_sum = ((3 + tops[i]) * sum - before_sum) % 10007;
    // 다음 sum 값이 음수라면 10007을 더함
    if (next_sum < 0) next_sum += 10007;
    // before_sum과 sum 갱신
    before_sum = sum;
    sum = next_sum;
  }

  return sum;
}
