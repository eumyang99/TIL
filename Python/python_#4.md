# 데이터 구조

1. 순서가 있는 데이터 구조
   - 문자열(String)
   - 리스트(List)
   - 튜플(Tuple)
2. 순서가 없는 데이터 구조
   - 세트(Set)
   - 딕셔너리(Dictionary)
3.  얕은 복사와 깊은 복사

---



### 문자열(String) 메서드

- 문자열 조회/탐색 및 검증 메서드

  |    S.find(x)    | **x의 첫번째 위치를 반환, 없으면 -1 반환**   |
  | :-------------: | :------------------------------------------- |
  | **S.index(x)**  | **x의 첫번째 위치를 반환, 없으면 오류 발생** |
  | **S.isalpha()** | **알파벳 문자 여부**                         |
  | **S.isupper()** | **대문자 여부**                              |
  | **S.islower()** | **소문자 여부**                              |
  | **S.istitle()** | **타이틀 형식 여부**                         |

  

- 문자열 변경 메서드

  |  **S.replace(old, new[ ,count])**  | **바꿀 대상 글자를 새로운 글자로 바꿔서 반환**               |
  | :--------------------------------: | ------------------------------------------------------------ |
  |        **S.stirp([chars])**        | **공백이나 특정 문자를 제거**                                |
  | **S.split(sep=None, maxsplit=-1)** | **공백이나 특정 문자를 기준으로 분리**                       |
  |  **'seperator'.join([iterable])**  | **구분자(seperator)로 iterable을 합침**                      |
  |         **S.capitalize()**         | **가장 첫번째 글자를 대문자로 변경**                         |
  |           **S.title()**            | **문자열 내 띄어쓰기 기준으로 각 단어의 첫글자는 대문자로, 나머지는 소문자로 변환** |
  |           **S.upper()**            | **모두 대문자로 변경**                                       |
  |           **S.lower()**            | **모두 소문자로 변경**                                       |
  |          **S.swapcase()**          | **대소문자 서로 변경**                                       |

  

### 리스트(List) 메서드

|        L.append(x)         | 리스트 마지막에 항목 x를 추가                          |
| :------------------------: | ------------------------------------------------------ |
|     **L.insert(i, x)**     | **리스트 인덱스 i에 항목 x를 삽입**                    |
|      **L.remove(x)**       | **리스트 0번째 x를 제거, 항목이 없으면 에러 표시**     |
|        **L.pop()**         | **리스트 가장 마지막 항목을 반환 후 제거**             |
|        **L.pop(i)**        | **리스트 인덱스 i에 있는 항목을 반환 후 제거**         |
|      **L.extend(m)**       | **순회형 m의 모든 항목들의 리스트 끝에 추가(+= 기능)** |
| **L.index(x, start, end)** | **리스트 가장 왼쪽 항목 x의 인덱스를 반환**            |
|      **L.reverse()**       | **리스트 역배열**                                      |
|        **L.sort()**        | **리스트 정렬**                                        |
|       **L.count(x)**       | **리스트에 존재하는 항**목 x의 갯수를 반환             |



### 튜플 메서드

- 튜플은 변경이 불가하기 때문에 값에 영향을 미치지 않는 메서드만 지원
- 리스트 메서드 중 항목을 변경하는 메서드들을 제외하고 대부분 동일



### 세트(Set) 메서드

|      S.copy()       | 세트의 얕은 복사본을 반환                                    |
| :-----------------: | ------------------------------------------------------------ |
|    **S.add(x)**     | **항목 x가 set에 없다면 추가**                               |
|     **S.pop()**     | **set에서 랜덤학 항목을 반환, 해당 항목을 제거, set가 비어있으면 에러** |
|   **S.remove(s)**   | **항목 x를 set에서 삭제, 항목이 없으면 에러**                |
|  **S.discard(x)**   | **항목 x가 set에 있으면 항목 x를 set에서 삭제**              |
|   **S.update(t)**   | **set T에 있는 모든 항목 중 set S에 없는 항목을 추가**       |
|    **S.clear()**    | **모든 항목 제거**                                           |
| **S.isdisjoint(t)** | **set S와 set T가 같은 항목을 갖고 있지 않으면 True 반환**   |
|  **S.issubset(t)**  | **set S가 set T의 하위 set이면 True 반환**                   |
| **S.isupperset(t)** | **set S가 set T의 상위 set이면 True 반환**                   |



### 딕셔너리(Dictionary) 메서드

|       D.clear()       | 모든 항목을 제거                                             |
| :-------------------: | ------------------------------------------------------------ |
|     **D.copy()**      | **딕셔너리 D의 얕은 복사본을 반환**                          |
|     **D.keys()**      | **딕셔너리 D의 모든 키를 담은 뷰를 반환**                    |
|    **D.values()**     | **딕셔너리 D의 모든 밸류를 담은 뷰를 반환**                  |
|     **D.items()**     | **딕셔너리 D의 모든 키-밸류 쌍을 담은 뷰를 반환**            |
|     **D.get(k)**      | **키 k의 값을 반환, 키 k가 딕셔너리 D에 없으면 None을 반환** |
|    **D.get(k, v)**    | **키 k의 값을 반환, 키 k가 딕셔너리 D에 없으면 v를 반환**    |
|     **D.pop(k)**      | **키 k의 값을 반환하고 키 k인 항목을 딕셔너리 D에서 삭제, 딕셔너리 D에 키 k가 없으면 에러 발생** |
|    **D.pop(k, v)**    | **키 k의 값을 반환하고 키 k인 항목을 딕셔너리 D에서 삭제, 딕셔너리 D에 키 k가 없으면  v를 반환** |
| **D.update([other])** | **딕셔너리 D의 값을 매핑하여 업데이트**                      |

---



### 얕은 복사와 깊은 복사

1.  할당(Assignment)
2.  얕은 복사(Shallow copy)
3. 깊은 복사(Deep copy)



- 할당

  - 대입 연산자 (=)

  - ```python
    A_lst = [1, 2, 3]
    copy_lst = A_lst
    print(A_lst, copy_lst) #[1, 2, 3], [1, 2, 3]
    
    copy_lst[0] = 'hello'
    print(A_lst, copy_lst) #['hello', 2, 3], ['hello', 2, 3]
    ```

  - 대입 연산자(=)를 통한 복사는 해당 객체에 대한 객체 참조를 복사

  - 해당 주소의 일부 값을 변경하는 경우 이를 참조하는 **모든 변수**에 영향



- 얕은 복사(shallow copy)

  - 슬라이스 연산자를 활용하여 연산된 결과를 복사(다른 주소)

  - ```py
    a = [1, 2, 3]
    b = a[:]
    print(a,b) #[1, 2, 3], [1, 2, 3]
    
    b[0] = 5
    print(a, b) #[1, 2, 3], [5, 2, 3]
    ```

    

  - 그러나 복사되는 리스트의 원소가 주소를 참조하는 경우(리스트 안에 리스트)

  - ```python
    a = [1, 2, ['X', 'Y']]
    b = a[:]
    print(a,b) #[1, 2, ['X', 'Y']], [1, 2, ['X', 'Y']]
    
    b[2][0] = 0
    print(a, b) #[1, 2, ['0', 'Y']], [1, 2, ['0', 'Y']]
    ```

  - 이 경우에는 슬라이스 연산자를 써도 처음 할당(Assignment)에서 마주한 문제가 다시 발생한다.



- 깊은 복사(Deeply copy)

  - ```python
    import copy
    a = [1, 2, ['X', 'Y']]
    b = copy.deepcopy(a)
    print(a,b) #[1, 2, ['X', 'Y']], [1, 2, ['X', 'Y']]
    
    b[2][0] = 0
    print(a, b) #[1, 2, ['X', 'Y']], [1, 2, ['0', 'Y']
    ```

  - deepcopy를 이용하면 이러한 문제가 발생하지 않고 완전히 주소가 다른 복사본을 만든다.

  - 그래서 `b[2][0]`의 값이 바뀌어도 다른 주소에 복사되었기 때문에 `a[2][0]`의 값이 따라 바뀌지 않는다.